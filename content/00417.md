---
title: Spring WebFlux入門
tags: ["Reactor", "RxJava", "Spring 5", "Spring WebFlux", "Java"]
categories: ["Programming", "Java", "org", "springframework", "web", "reactive"]
---


> この記事の内容はSpring 5.0.0.RC1時点でのものです。5.0.0.RELEASE時での動作保証はありません。またSNAPSHOTを使っているため、このままでは動作しないこともあります。

[Spring WebFlux](http://docs.spring.io/spring/docs/5.0.0.RC1/spring-framework-reference/web.html#web-reactive)はSpring 5から追加された、ノンブロッキングなランタイム上でリアクティブプログラミングできる新しいWebフレームワークです。

![image](https://qiita-image-store.s3.amazonaws.com/0/1852/55642680-438b-2b75-d957-3e8e0ddcff15.png)

上の図が示す通り、これまでのSpring MVCの横に位置するコンポーネントです。
これまでのSpring MVCがサーブレットコンテナ上でServlet APIをベースにしてきたフレームワークであったのに対し、
Spring WebFluxはServlet APIは使用せず、[Reactive Streams](http://www.reactive-streams.org/)及びその実装である[Reactor](https://projectreactor.io/)をベースとした新しいHTTP API上に実装されています。ランタイムとしてはNetty、Undertow(サーブレットコンテナじゃない方)といったノンブロッキングランタイムが使えます。またServlet 3.1で導入されたNon-Blocking APIを使用したTomcat, Jetty実装も用意されています。ただし、Spring WebFluxからはServlet APIは見えません。

Spring WebFlux上のプログラミングモデルとしては

* @Controlller
* Router Functions

の2パターンが用意されています。前者はこれまでSpring MVCで使用してきたアノテーションベースのContoller実装方法そのものです。
つまりランタイムは変わるけどControllerのプログラミング方法は同じです。
後者の方はラムダベースの全く新しいControllerの実装方法になります。Node.jsのExpressみたいなものをイメージしていただければと思います。

本記事では両方の簡単な使い方を紹介します。

ちなみに詳しくはJava Day Tokyo 2017のD1-D5で話すので聞きに来てください。
http://www.oracle.co.jp/events/javaday/2017

### プロジェクト作成

まずはプロジェクトを作成します。Spring Boot 2.0からSpring 5に対応しています。

curlコマンドで雛形プロジェクトを作成します。Windowsの場合はBashから実行してください。

```
curl https://start.spring.io/starter.tgz \
       -d bootVersion=2.0.0.BUILD-SNAPSHOT \
       -d artifactId=hello-webflux \
       -d baseDir=hello-webflux \
       -d dependencies=webflux \
       -d applicationName=HelloWebFluxApplication | tar -xzvf -
```

できた`hello-webflux`プロジェクトをIDEで開いてください。

### @Controllerモデル

まずは@ControllerモデルのHello Worldを試します。

`src/main/java/com/example/HelloController.java`を作成して下さい。

``` java
package com.example;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Flux;

@RestController
public class HelloController {

	@GetMapping("/")
	Flux<String> hello() {
		return Flux.just("Hello", "World");
	}
}

```

`com.example.HelloWebFluxApplication`クラスの`main`メソッドを実行するとSpring WebFluxのアプリケーションが立ち上がります。

```
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::  (v2.0.0.BUILD-SNAPSHOT)

2017-05-09 03:25:20.123  INFO 92125 --- [           main] com.example.HelloWebFluxApplication      : Starting HelloWebFluxApplication on jpxxmakitm1.corp.emc.com with PID 92125 (/private/tmp/hello-webflux/target/classes started by makit in /private/tmp/hello-webflux)
2017-05-09 03:25:20.128  INFO 92125 --- [           main] com.example.HelloWebFluxApplication      : No active profile set, falling back to default profiles: default
2017-05-09 03:25:20.199  INFO 92125 --- [           main] .r.c.ReactiveWebServerApplicationContext : Refreshing org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext@769e7ee8: startup date [Tue May 09 03:25:20 JST 2017]; root of context hierarchy
2017-05-09 03:25:20.877  WARN 92125 --- [           main] o.h.v.m.ParameterMessageInterpolator     : HV000184: ParameterMessageInterpolator has been chosen, EL interpolation will not be supported
2017-05-09 03:25:21.045  WARN 92125 --- [           main] o.h.v.m.ParameterMessageInterpolator     : HV000184: ParameterMessageInterpolator has been chosen, EL interpolation will not be supported
2017-05-09 03:25:21.269  INFO 92125 --- [           main] s.w.r.r.m.a.RequestMappingHandlerMapping : Mapped "{[/],methods=[GET]}" onto reactor.core.publisher.Flux<java.lang.String> com.example.HelloController.hello()
2017-05-09 03:25:21.296  INFO 92125 --- [           main] o.s.w.r.handler.SimpleUrlHandlerMapping  : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.reactive.resource.ResourceWebHandler]
2017-05-09 03:25:21.297  INFO 92125 --- [           main] o.s.w.r.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.reactive.resource.ResourceWebHandler]
2017-05-09 03:25:21.381  INFO 92125 --- [           main] o.s.w.r.r.m.a.ControllerMethodResolver   : Looking for @ControllerAdvice: org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext@769e7ee8: startup date [Tue May 09 03:25:20 JST 2017]; root of context hierarchy
2017-05-09 03:25:21.947  INFO 92125 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup
2017-05-09 03:25:22.042  INFO 92125 --- [           main] o.s.b.web.embedded.netty.NettyWebServer  : Netty started on port(s): 8080
2017-05-09 03:25:22.048  INFO 92125 --- [           main] com.example.HelloWebFluxApplication      : Started HelloWebFluxApplication in 3.044 seconds (JVM running for 3.679)
```

いつものSpring BootならTomcatが立ち上がっていましたが、今回はNettyが起動していることがわかります。

`curl`で`localhost:8080`にアクセスしてください。

```
$ curl -v localhost:8080
> GET / HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.43.0
> Accept: */*
> 
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: text/plain;charset=UTF-8
< 
```

HellWorldが表示されました。

`Flux`はReactive Streamsの`Publisher`を実装したN要素のストリームを表現するReactorのクラスです。
デフォルトでは`text/plain`でレスポンスが帰りましたが、

* Server-Sent Event
* JSON Stream

で返すこともできます。

Server-Sent Eventで返す場合は`Accept`ヘッダに`text/event-stream`を指定してください。

```
$ curl -v localhost:8080 -H 'Accept: text/event-stream'
> GET / HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.43.0
> Accept: text/event-stream
> 
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: text/event-stream
< 
data:Hello

data:World
```

JSON Streamで返すときは`Accept`ヘッダに`application/stream+json`を指定しますが、今回のケース（文字列ストリーム）では見た目が`text/plain`の時と変わりません。

```
$ curl -v localhost:8080 -H 'Accept: application/stream+json'
> GET / HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.43.0
> Accept: application/stream+json
> 
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/stream+json;charset=UTF-8
< 
HelloWorld
```

次のもう少しStream感のあるレスポンスを返しましょう。

`Flux`は`java.util.stream.Stream`から生成することもできます。

次の`stream`メソッドを作成して、無限`Stream`を作成し、そのうちの10件を`Flux`に変換して返却してください。

``` java
package com.example;

import java.util.Collections;
import java.util.Map;
import java.util.stream.Stream;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Flux;

@RestController
public class HelloController {

	@GetMapping("/")
	Flux<String> hello() {
		return Flux.just("Hello", "World");
	}

	@GetMapping("/stream")
	Flux<Map<String, Integer>> stream() {
		Stream<Integer> stream = Stream.iterate(0, i -> i + 1); // Java8の無限Stream
		return Flux.fromStream(stream.limit(10))
				.map(i -> Collections.singletonMap("value", i));
	}
}

```
`com.example.HelloWebFluxApplication`クラスを再起動してください。

`/stream`に対する三種類のレスポンスはそれぞれ、

通常のJSON

```
$ curl -v localhost:8080/stream
> GET /stream HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.43.0
> Accept: */*
> 
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/json;charset=UTF-8
< 
[{"value":0},{"value":1},{"value":2},{"value":3},{"value":4},{"value":5},{"value":6},{"value":7},{"value":8},{"value":9}]
```

Server-Sent Event

```
$ curl -v localhost:8080/stream -H 'Accept: text/event-stream'
> GET /stream HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.43.0
> Accept: text/event-stream
> 
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: text/event-stream
< 
data:{"value":0}

data:{"value":1}

data:{"value":2}

data:{"value":3}

data:{"value":4}

data:{"value":5}

data:{"value":6}

data:{"value":7}

data:{"value":8}

```

JSON Stream

```
$ curl -v localhost:8080/stream -H 'Accept: application/stream+json'
> GET /stream HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.43.0
> Accept: application/stream+json
> 
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/stream+json;charset=UTF-8
< 
{"value":0}
{"value":1}
{"value":2}
{"value":3}
{"value":4}
{"value":5}
{"value":6}
{"value":7}
{"value":8}
{"value":9}
```

となります。これで普通のJSON(`application/json`)とJSON Stream(`application/stream+json`)の違いがわかったと思います。

実は`limit`をつける必要はなく、そのまま無限Streamを返すこともできます。
これは普通のControllerの発想だと永遠にレスポンスが返ってこないことになります。実は`application/json`の場合はレスポンスが返りません(Integerがオーバーフローしたら返るかも？)。
なのでまずはあえて`limit`をつけました。Server-Sent EventとJSON Streamは無限Streamを返すこともできます。
試してみましょう。

``` java
package com.example;

import java.util.Collections;
import java.util.Map;
import java.util.stream.Stream;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Flux;

@RestController
public class HelloController {

	@GetMapping("/")
	Flux<String> hello() {
		return Flux.just("Hello", "World");
	}

	@GetMapping("/stream")
	Flux<Map<String, Integer>> stream() {
		Stream<Integer> stream = Stream.iterate(0, i -> i + 1);
		return Flux.fromStream(stream) // limitを外す
                                .map(i -> Collections.singletonMap("value", i));
	}
}
```

Server-Sent EventもJSON Stream以下のように返りますが、Ctrl+Cで止めるまですごいスピードでストリームが流れます。

Server-Sent Event

```
$ curl -v localhost:8080/stream -H 'Accept: text/event-stream'
> GET /stream HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.43.0
> Accept: text/event-stream
> 
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: text/event-stream
< 
data:{"value":0}

data:{"value":1}

data:{"value":2}

data:{"value":3}

data:{"value":4}

data:{"value":5}

data:{"value":6}

data:{"value":7}

data:{"value":8}

data:{"value":9}

data:{"value":10}

data:{"value":11}

data:{"value":12}

data:{"value":13}

data:{"value":14}

... 
```

JSON Stream

```
$ curl -v localhost:8080/stream -H 'Accept: application/stream+json'
> GET /stream HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.43.0
> Accept: application/stream+json
> 
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/stream+json;charset=UTF-8
< 
{"value":0}
{"value":1}
{"value":2}
{"value":3}
{"value":4}
{"value":5}
{"value":6}
{"value":7}
{"value":8}
{"value":9}
{"value":10}
{"value":11}
{"value":12}
{"value":13}
{"value":14}
...
```

ストリームをゆっくり返したい場合は`Flux.interval(Duration)`とzipしたStreamを返します。

```
package com.example;

import java.time.Duration;
import java.util.Collections;
import java.util.Map;
import java.util.stream.Stream;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Flux;

@RestController
public class HelloController {

	@GetMapping("/")
	Flux<String> hello() {
		return Flux.just("Hello", "World");
	}

	@GetMapping("/stream")
	Flux<Map<String, Integer>> stream() {
		Stream<Integer> stream = Stream.iterate(0, i -> i + 1);
		return Flux.fromStream(stream).zipWith(Flux.interval(Duration.ofSeconds(1)))
				.map(tuple -> Collections.singletonMap("value", tuple.getT1() /* タプルの1つ目要素 = Stream<Integer>の要素 */));
	}
}
```

これで毎秒1件ずつゆっくりデータが返ってきます。

```
$ curl -v localhost:8080/stream -H 'Accept: application/stream+json'
> GET /stream HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.43.0
> Accept: application/stream+json
> 
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: application/stream+json;charset=UTF-8
< 
{"value":0}
{"value":1}
{"value":2}
{"value":3}
{"value":4}
{"value":5}
```

### Router Functionsモデル

To Be Continued
