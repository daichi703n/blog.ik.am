---
title: Java用Validatorライブラリ"YAVI"(ヤヴァイ)の紹介
tags: ["Java", "YAVI"]
categories: ["Programming", "Java", "am", "ik", "yavi"]
---

[YAVI](https://github.com/making/yavi)というJava用ValidatorライブラリのYAVIを作っています。
*Y*et *A*nother *V*al*i*dation for Javaの略で"ヤヴァイ"と呼びます。

この記事では何でYAVI作っているのか、何が面白いのかを紹介します。

**目次**

<!-- toc -->

### 動機

Javaには一応、標準の[Bean Validation](https://beanvalidation.org/)があり、
実装としては[Hibernate Validator](https://hibernate.org/validator/)が一般的に使われています。
Spring Bootでもデフォルトで含まれるので、多くの人はこれを使っていますし、これで事足りることが多いです。

YAVIを作ったのはBean Validationが嫌いだからではありません。なので、Bean Validationを批判する訳ではないですし、
Bean Validationで問題を感じていなければそのまま使えば良いと思います。

作ったきっかけは、"[Spring WebFlux.fn](https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-fn)で使えるValidatorが欲しかった"という点です。
アノテーションベースのSpring MVCやSpring WebFluxとは異なり、FunctionベースのSpring WebFlux.fnにはバリデーションがサポートされていません。
好きなValidationライブラリを持ち込んで任意のタイミングで呼び出せば良いと言う割り切りになっています。

Spring WebFlux.fnはアノテーション(リフレクション)を使わないラムダベースのWebフレームワークであり、
ここでリフレクションバリバリのBean Validationを使うのは合わないかなと感じ、WebFlux.fnでの使用フィットするValiadtorが欲しいと言うのがYAVIを作り始めた動機です。

### コンセプト

YAVIを作るに当たってのコンセプトとしては、FunctionベースのWebフレームワークにフィットすることを前提としているため、

* リフレクションは使わない
* アノテーションは使わない
* Java Beansを前提としない

そして、WebFlux.fn以外のフレームワークでも使えるように

* 3rd partyライブラリに依存しない

を掲げています。

リフレクションの代わりにラムダ式、メソッド参照を多用します。
[Spark Java](http://sparkjava.com/)や[javalin](https://javalin.io/)など、
Micro Frameworkと謳っている(けどバリデーションはサポートしていない)ものとも併せて使えます。


これらのコンセプトを基に、

* 使いやすいプログラミングモデルの提供
* バリデータとしてエンタープライズレディな機能の提供

を目指しています。Coolさと泥臭さを両立させたいと思っています。
泥臭さの提供にはSIer時代のバックグラウンドが活きると思います。

### 基本的な使い方

Mavenの場合は`pom.xml`に

```xml
<dependency>
  <groupId>am.ik.yavi</groupId>
  <artifactId>yavi</artifactId>
  <version>x.y.z</version>
</dependency>
```

Gradleの場合は`build.gradle`に

```
compile('am.ik.yavi:yavi:x.y.z')
```

を追加してください。バージョン(`x.y.z`)は[GitHub](https://github.com/making/yavi/releases)から確認してください。


次の`User`クラスを例にあげます。

```java
public class User {
  private final String name;

  private final String email;

  private final Integer age;

  public User(String name, String email, Integer age) {
    this.name = name;
    this.email = email;
    this.age = age;
  }

  public String name() {
    return this.name;
  }

  public String email() {
    return this.email;
  }

  public Integer age() {
    return this.age;
  }
}
```

`User`クラスに対して、まずはYAVIでバリデーションを定義します。定義場所はどこでも良いです。

```java
import am.ik.yavi.core.Validator;

static final Validator<User> validator = Validator.<User> builder() // builder(User.class)でも可
        .constraint(User::name, "name", c -> c.notNull() //
            .greaterThanOrEqual(1) //
            .lessThanOrEqual(20)) //
        .constraint(User::email, "email", c -> c.notNull() //
            .greaterThanOrEqual(5) //
            .lessThanOrEqual(50) //
            .email()) //
        .constraint(User::age, "age", c -> c.notNull() //
            .greaterThanOrEqual(0) //
            .lessThanOrEqual(200))
        .build();
```

`constraint`メソッドでラムダ式/メソッド参照に対してメソッドチェーンで制約を追加する形式です。
第一引数のラムダ式の型から、設定できる制約が決まります。例えば`email()`は文字列を返すラムダに対してしか設定できません。
Bean Validationでは型の違うプロパティへの制約は実行時エラーになるので、ここはYAVIのメリットと言えます。

> **余談**
> 
> 第二引数は制約対象の名前で、ここだけ文字列で指定する必要があります。リクフレクションを使用しないため、ここは妥協ポイントでした。
> Annotation Processorを使えばコンパイル時にメタ情報を生成してそれを使用することで文字列は指定しなくてもよくなりますが、
> アノテーションを使用しないと言うコンセプトに反します。アイディアとしては文字列以外にも対象名を返すインタフェースとそれと受け取るメソッドだけを作り、
> インタフェースを実装したクラスは別プロジェクトにして、そちらでAnnotation Processorから生成すると言うのも考えています。

バリデーションの実施方法は

```java
User user = new User("making", "making@example.com", 20);
ConstraintViolations violations = validator.validate(user);
```

です。`ConstraintViolations`は制約違反項目を表現する`ConstraintViolation`の`List`です。

```java
violations.isValid(); // true or false 
```

で検証結果がわかります。
違反項目の詳細は`ConstraintViolations`オブジェクトをイテレートすれば良いです。
エラーメッセージは次のように出力できます。

```java
violations.forEach(x -> System.out.println(x.message()));
```

JSONでシリアライズされるときに必要であろう項目だけをまとめた便利メソッドとして、`details()`メソッドがあります。

```java
List<ViolationDetail> details = violations.details();
```

REST API実装時は、これをそのまま返すか、これをフィールドにもつエラーオブジェクトを作れば良いでしょう。


Bean Validationと比較して、

* 各種制約を実現する方法は[こちら](https://github.com/making/yavi/blob/develop/docs/FromBeanValidationToYAVI.md#from-bean-validation-to-yavi)
* ネストしたBeanやコレクションに対する制約の設定方法は[こちら](https://github.com/making/yavi/blob/develop/docs/FromBeanValidationToYAVI.md#valid)
* 独自制約の実装方法は[こちら](https://github.com/making/yavi/blob/develop/docs/FromBeanValidationToYAVI.md#custom-constraint)

を参照してください。Bean Validationからのfrom-to形式でサンプルを記載しています。

### Either APIの導入

ここまで実装して0.0.1をリリースし、実際に当初の目的であったSpring WebFlux.fnで使用してみました。

```java
static RouterFunction<ServerResponse> routes() {
  return route(POST("/"), req -> req.bodyToMono(User.class) //
      .flatMap(body -> {
        ConstraintViolations violations = validator.validate(body);
        if (violations.isValid(())) {
          return ok().syncBody(body);
        } else {
          Map<String, Object> res = new LinkedHashMap<>();
          res.put("message", "Invalid request body");
          res.put("details", violations.details());
          return badRequest().syncBody(res);
        }
      }));
}
```

うーん、悪くないんだけど、少し残念感があります。
具体的にいうと`violations`のif文で処理の流れがせき止められている部分が残念です。
せっかくフレームワークが関数型スタイルで書けるので、もう少し関数型にフィットした書き方がしたいです。

これの課題に対して、"Either"という考え方があることをわかりました。
ヒントとなったのは[@gakuzzzz](https://twitter.com/gakuzzzz)さんが書かれた[この記事](https://gist.github.com/gakuzzzz/0c779d5335f4b2bff596)で、ぱっと見"うむ、わからん"という感じでしたが、
[Vavr](https://www.vavr.io/vavr-docs/#_either)というJavaに関数型プログラミングの要素を導入するライブラリを参考にし、`Either`を使えばこの課題を解決できることがわかりました。

`Optional`に少し近いですが、`Either`は二つ(left, right)のオブジェクトのどちらかを表現するクラスです。

```java
Either<String, Integer> either = Either.left("Hello");
```
あるいは
```java
Either<String, Integer> either = Either.right(100);
```
という表現ができます。
`Either`に対して`fold`メソッドで同じ型のオブジェクトに射影することができます。

```java
String ret = either.fold(s -> s.toUpperCase(), i -> i.toString());
```

`Either`クラスの実装は非常にシンプルなので、他のAPIは[ソース](https://github.com/making/yavi/blob/develop/src/main/java/am/ik/yavi/fn/Either.java)を確認してください。

これを使ってValidationの結果を表現すれば、関数型のプログラミングにフィットします。Validationの文脈では右と正解を掛けて、rightに検証結果がOKだった場合のオブジェクトをleftを違反内容を含めるのが慣例のようです。

先の例をEitehrを使って書き換えると、次のようになります。

```java
static RouterFunction<ServerResponse> routes() {
  return route(POST("/"), req -> req.bodyToMono(User.class) //
      .flatMap(body -> validator.validateToEither(body) //
          .fold(violations -> {
            Map<String, Object> res = new LinkedHashMap<>();
            res.put("message", "Invalid request body");
            res.put("details", violations.details());
            return badRequest().syncBody(res);
          }, user -> ok().syncBody(user))));
}
```

if文が消えて、ラムダ式だけで表現できるようになりました。これでSpring WebFlux.fnに合ったバリデーションが実現できます。


<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">モナドは抽象度が高くて理解が難しいというのはまあわかるが、EitherやValidationのような具象概念はそれなりに使いやすいのではなかろうか。みんなListがモナドインスタンス定義できると知らなくてもList便利に使ってるし</p>&mdash; がくぞ (@gakuzzzz) <a href="https://twitter.com/gakuzzzz/status/1031770151870332928?ref_src=twsrc%5Etfw">August 21, 2018</a></blockquote>

確かに`Either`を実際に解決したい問題に対して適用すると、とてつもなく強力だと言うことが実感できました。

WebFlux.fnに限らず`Either`を使うと便利です。
例えば、ユーザーからの入力をFormオブジェクトで受け取り、バリデーションが通った後にDomainオブジェクトに変換するという処理は次のように簡潔に表現できます。

```java
validator.validateToEither(form)
  .fold(violations -> "NG",
    f -> {
      Foo foo = f.toDomainObject();
      foo.doSomething();
      return "OK";
    }
  );
```

### エラーメッセージ補間

エラーメッセージの解決はValidatorライブラリの1つの大きなテーマです。
YAVIではここは本格的には取り組んでおらず、現時点では"Bring Your Own MessageInterpolator"のスタンスです。
`MessageFormatter`インタフェースだけを用意しており、
デフォルトでは`java.text.MessageFormatter`を使った極めてシンプルな実装が使用されます。

メッセージとキーの一覧は[Enum](https://github.com/making/yavi/blob/develop/src/main/java/am/ik/yavi/constraint/ViolationMessage.java)で定義してあるので、

ここからプロパティファイルを生成して、そのプロパティファイル(`messages.properties`)でメッセージを定義したい場合は、次のような実装をすれば良いです。

```java
import java.text.MessageFormat;
import java.util.Locale;
import java.util.MissingResourceException;
import java.util.ResourceBundle;

import am.ik.yavi.constraint.ViolationMessage;
import am.ik.yavi.message.MessageFormatter;

public enum ResourceBundleMessageFormatter implements MessageFormatter {
    SINGLETON;

    @Override
    public String format(String messageKey, String defaultMessageFormat, Object[] args,
            Locale locale) {
        ResourceBundle resourceBundle = ResourceBundle.getBundle("messages", locale);
        String format;
        try {
            format = resourceBundle.getString(messageKey);
        }
        catch (MissingResourceException e) {
            format = defaultMessageFormat;
        }
        try {
            String target = resourceBundle.getString((String) args[0]);
            args[0] = target;
        }
        catch (MissingResourceException e) {
        }
        return new MessageFormat(format, locale).format(args);
    }
}
```

`MessageFormatter`を差し替えたい場合は次のように設定できます。

```java
static final Validator<User> validator = Validator
            .builder(User.class)
            .messageFormatter(ResourceBundleMessageFormatter.SINGLETON)
            // ...
            .build()
```

プロジェクト共通で使いたい場合は、次のようなユーティリティクラスを作れば良いでしょう。


```java
public static ValidatorBuilder<T> validator(Class<T> clazz) {
  return Validator.builder(clazz).messageFormatter(ResourceBundleMessageFormatter.SINGLETON);
}
```

エラーメッセージのこだわりとして、Bean Validationと比較して、

* エラーメッセージにデフォルトで項目名を含める
* エラーメッセージに違反した内容を含められるようにする

が対応されています。
メッセージの第一プレースホルダ`{0}`には項目名、最後の項目には違反値が入ります。

特に2つめに関しては、一般的なValidationライブラリでは対応されていないため、例えば、"xxxxxは100文字以下にしてください"とエラーメッセージが返って来ても、
実際に今入力した内容が何文字としてカウントされているのかがわからないため、少しずつ文字を削ってトライするということがたまにあります。
ユーザーがこういう無駄なことをしなくても良いようにデフォルトで次のようなメッセージが表示されます。

![image](https://user-images.githubusercontent.com/106908/44784067-4b010600-abc7-11e8-8878-930d017405bb.png)

